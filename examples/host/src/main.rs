// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{METHOD_ELF, METHOD_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use verity_tls::{
    merkle::generate_merkle_tree,
    tlsn_core::{presentation::Presentation, CryptoProvider},
};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let full_presentation: Presentation =
        serde_json::from_str(fixtures::proof::PRESENTATION_32B_FULL)?;

    let mut private_presentation = full_presentation.clone().wipe_public_data()?;
    println!("private_presentation.precompute_encodings()");
    private_presentation.precompute_encodings()?;

    let mut public_presentation = full_presentation.clone();
    println!("public_presentation.precompute_encodings()");
    public_presentation.precompute_encodings()?;
    public_presentation = public_presentation.wipe_private_data()?;
    public_presentation = public_presentation.wipe_public_data()?;

    full_presentation.verify_full(&CryptoProvider::default())?;

    // std::fs::write(
    //     "../../fixtures/proof/precompute-32b_no_data.json",
    //     serde_json::to_string_pretty(&presentation).unwrap(),
    // )
    // .unwrap();

    // let env = write_input_1(&presentation);
    // let env = write_input_2(&presentation)?;
    let env = write_input_3(&private_presentation)?;

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove(env, METHOD_ELF).unwrap();

    // extract the receipt.
    let receipt = prove_info.receipt;

    // For example:
    let verified_by_guest: String = receipt.journal.decode().unwrap();

    let leaf = serde_json::to_string(&public_presentation)?;

    let merkle_tree = generate_merkle_tree(&vec![leaf]);
    let root = merkle_tree.root().unwrap();
    let verified_by_host = hex::encode(root);

    println!("host: [{}]", verified_by_host,);
    println!("guest: [{}]", verified_by_guest,);

    // Assert that the proof verification within the zkVM matches the proof verification by the host
    assert_eq!(verified_by_host, verified_by_guest);

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(METHOD_ID).unwrap();

    Ok(())
}

#[allow(dead_code)]
fn write_input_1(presentation: &Presentation) -> ExecutorEnv<'_> {
    ExecutorEnv::builder()
        .write(presentation)
        .unwrap()
        .build()
        .unwrap()
}

#[allow(dead_code)]
fn write_input_2(
    presentation: &Presentation,
) -> Result<ExecutorEnv<'_>, Box<dyn std::error::Error>> {
    let input = serde_json::to_string(presentation)?;
    let input: &[u8] = input.as_bytes();

    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    Ok(env)
}

#[allow(dead_code)]
fn write_input_3(
    presentation: &Presentation,
) -> Result<ExecutorEnv<'_>, Box<dyn std::error::Error>> {
    let input_bytes = bincode::serialize(&presentation)?;

    println!("Host is writing input_bytes: {}", input_bytes.len());

    let env = ExecutorEnv::builder()
        .write(&input_bytes.len())
        .unwrap()
        .write_slice(&input_bytes)
        .build()?;

    Ok(env)
}
