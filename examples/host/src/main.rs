use blake3::Hash;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{METHOD_ELF, METHOD_ID};
use risc0_zkvm::default_prover;
use verity_tls::{
    hash_presentations,
    tlsn_core::{presentation::Presentation, CryptoProvider},
};

use crate::interop::read_response;

mod interop;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let full_presentation: Presentation =
        serde_json::from_str(fixtures::proof::PRESENTATION_1KB)?;

    let mut private_presentation = full_presentation.clone();
    private_presentation.precompute_encodings()?;

    let mut guest_request = Vec::new();
    guest_request.push(private_presentation);

    let mut public_presentation = full_presentation.clone();
    public_presentation = public_presentation.wipe_private_data()?;

    let mut host_request = Vec::new();
    host_request.push(public_presentation);

    let host_response = process_request(host_request.clone())?;

    let env = interop::write_request(&guest_request)?;

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover.prove(env, METHOD_ELF).unwrap();

    // extract the receipt.
    let receipt = prove_info.receipt;

    let guest_response = read_response(&receipt)?;

    println!("host: [{}]", host_response.to_hex(),);
    println!("guest: [{}]", guest_response.to_hex(),);

    // Assert that the proof verification within the zkVM matches the proof verification by the host
    assert_eq!(host_response, guest_response);

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(METHOD_ID).unwrap();

    Ok(())
}

fn process_request(presentations: Vec<Presentation>) -> Result<Hash, Box<dyn std::error::Error>> {
    let mut public_presentations = Vec::<Presentation>::new();

    for mut presentation in presentations.into_iter() {
        presentation.precompute_encodings()?;

        public_presentations.push(presentation.clone());

        presentation.verify_public_facets(&CryptoProvider::default())?;
    }

    Ok(hash_presentations(&public_presentations))
}
